<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="algcodes-sage-exercises">
    <title>Exercícios em Sage</title>

    <exercise number="1">
        <statement>
            <p>Construa o código (binário) Golay com o construtor <c>codes.GolayCode()</c>.  Leia a documentação para assegurar-se de construir a versão binária (e não a ternária), e não construa a versão estendida (que é a default).</p>

            <ol>
                <li><p>Use métodos Sage para calcular o comprimento, a dimensão e a distância mínima do código.</p></li>
                <li><p>Quantos erros podem ser detectados neste código? Quantos pode corrigir?</p></li>
                <li><p>Encontre uma palavra distinta de zero no código e introduza três erros somando um vetor com três 1's (de sua escolha) para criar uma mensagem recebida. Mostre que a mensagem se decodifica corretamente.</p></li>
                <li><p>Recicle suas escolhas da parte anterior, mas agora adicione um outro erro. A mensagem recebida é decodificada corretamente?</p></li>
            </ol>
        </statement>
        
    </exercise>

    <exercise number="2">
        <statement>
            <p>Uma técnica que permita melhorar as características de um código é adicionar um bit de paridade geral, tal como o bit de paridade do código <acro>ASCII</acro> descrito no Exemplo<nbsp/><xref ref="example-algcodes-even-parity"/>.  Tais códigos são conhecidos como versões <term>estendidas</term> do código original.</p>

            <ol>
                <li><p>Construa o código de Golay binário e obtenha a matriz verificadora. Use comandos Sage para estender esta matriz criando uma nova matriz de paridade que considere um bit de paridade global adicional. Os métodos <c>.augment()</c> e <c>.stack()</c> para matrizes podem ser úteis, assim como os construtores <c>zero_vector()</c> e <c>ones_matrix()</c> (recordando que especificamos as entradas binárias como pertencentes ao corpo <c>GF(2)</c>.)</p>

                <p>Crie o código estendido entregando a matriz de paridade aumentada ao construtor <c>codes.from_parity_check_matrix()</c> e calcule o comprimento, dimensão e distância mínima de código estendido.</p></li>

                <li><p>Em que sentido são melhores as características deste código novo? A que custo?</p></li>

                <li><p>Agora crie o código Golay binário estendido com <c>codes.GolayCode()</c> e a opção apropriada para obter a versão estendida. Com alguma sorte, as listas ordenadas de suas palavras e as do código implementado em Sage, serão as mesmas. Senão, o método <c>.is_permutation_equivalent()</c> deverá retornar <c>True</c> indicando que seu código e Sage são simplesmente rearranjos um do outro.</p></li>
            </ol>
        </statement>
        
    </exercise>

    <exercise number="3">
        <statement>
            <!--
            <p><em>Note:</em> This problem is on holiday (as of Sage 6.7), while some buggy Sage code for the minimum distance of a Hamming code gets sorted out.  The <c>r = 2</c> case produces an error message and for <c>r &gt; 5</c> the computation of the minimum distance has become intolerably slow.  So it is a bit harder to make a reasonable conjecture from just <m>3</m> cases.</p>
            -->
            <p>O dual de um código de blocos <m>(n,k)</m> é formado pelo conjunto dos vetores binários ortogonais a todos os vetores do código original. O Exercício<nbsp/><xref ref="exercise-algcodes-dual-code"/> descreve esta construção e pergunta por algumas de suas propriedades.</p>

            <p>Podemos obter o dual de um código em Sage com o método <c>.dual_code()</c>.  Construa os códigos de Hamming binários, e seus duais, com o parâmetro <c>r</c> variando desde <c>2</c> até <c>5</c>.  Construa uma tabela com seis colunas (possivelmente usando a função <c>html.table()</c>) que liste <m>r</m>, o comprimento do código, a dimensão do código original, a do seu dual, a distância mínima do código e de seu dual.</p>

            <p>Conjecture fórmulas para a dimensão e distância mínima do dual de um código de Hamming em termos do parâmetro <m>r</m>.</p>
        </statement>
        
    </exercise>

    <exercise number="4">
        <statement>
            <p>Um código com distância mínima <m>d</m> se chama <term>perfeito</term> se todo vetor possível está a uma distância menor ou igual a <m>(d-1)/2</m> de alguma palavra do código.  Se expandimos nossa ideia de geometria para incluir a noção de distância de Hamming como a métrica, então  podemos falar de uma esfera de raio <m>r</m> em torno de um vetor ou palavra. Para um código de comprimento <m>n</m>, uma esfera deste tipo contém <me>1 + {n\choose 1} + {n\choose 2} + \cdots + {n\choose r}</me> vetores em seu interior.  Para um código perfeito, as esferas de raio <m>(d-1)/2</m> centradas nas palavras do código particionam exatamente o espaço de todos os vetores possíveis.  (Isto é o que estabelece uma relação entre a teoria de códigos e os problemas de empacotamento de esferas.)</p>

            <p>Uma consequência de que um código de dimensão <m>k</m> seja perfeito é que <me>2^k\left({n\choose 0} + {n\choose 1} + {n\choose 2} + \cdots + {n\choose \frac{d-1}{2}}\right) = 2^n</me>  Reciprocamente, se um código tem distância mínima <m>d</m> e cumpre a condição anterior, então o código é perfeito.</p>

            <p>Escreva uma função em Sage, chamada <c>is_perfect()</c> que tome um código linear como entrada e retorne <c>True</c> ou <c>False</c> se o código for ou não perfeito.  Demonstre sua função verificando que o código de Golay binário é perfeito, e use um loop para verificar que os códigos de Hamming binários são perfeitos para longitudes menores que <m>32</m>.</p>
        </statement>
        
    </exercise>

    <!-- Potential exercise 5: probabilty and Shannon bound -->
</exercises>
