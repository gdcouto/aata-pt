<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="cosets-sage-exercises">
	<title>Exercícios em Sage</title>

	<introduction>
		<p>Os seguintes exercícios são menos sobre subgrupos e mais sobre como usar Sage como uma ferramenta experimental.  Eles são criados para ajudar você ser mais experiente e expressivo enquanto você escreve os comandos em Sage.  Teremos várias oportunidades de trabalhar com classes laterais e subconjuntos nos próximos capítulos.  Estes exercícios não contém muita orientação e ficam cada vez mais desafiantes a medida que continuamos.  Eles são formulados para que você explore,  ou confirme, resultados apresentados neste capítulo ou em capítulos anteriores.</p>

		<p><alert>Importante</alert>: Você deve responder cada um dos três problemas com uma única (complicada) linha de Sage que tenha como resultado <c>True</c>.  Uma <q>única linha</q> quer dizer que você terá vários comandos aglomerados de jeitos complexos.  Não significa vários comando em Sage separados por semi-colunas e escritos em uma única linha.  Não esqueça de incluir passos intermediários usados para construir sua solução, mas use intervalos de valores menores para que o sistema não fica sobrecarregado com várias outputs.  Isso irá ajudar você e o corretor do seu trabalho, tenha confiança que a versão final está correta.</p>

		<p>Quando você verificar a divisibilidade dos inteiros, lembre que <c>range()</c> gera inteiros comuns, que são simples com relação sua funcionalidade. O comando <c>srange()</c> produz inteiros Sage, que tem  mais capacidades.  (Vejo o último exercíci como um exemplo.)  E recorde que uma lista é uma forma compacta de examinar muitoas possibilidades de uma vez.</p>
	</introduction>


	<exercise number="1">
		<statement>
			<p>Use <c>.subgroups()</c> para encontrar um exemplo de um grupo <m>G</m> e um inteiro  <m>m</m>, tal que  (a) <m>m</m> divide a ordem de  <m>G</m>, e (b) <m>G</m> não tem subgrupo de ordem  <m>m</m>.  (Não use o grupo  <m>A_4</m> como <m>G</m>, pois este está no texto.)  Escreva somente uma linha de código Sage que contenha toda a lógica necessária para produzir  <m>m</m> como resposta.  (Pode dar um nome simples a seu grupo em uma linha anterior e então chamar ele por esse nome.) A seguir temos um exemplo mutio simples que pode ajudar a estrutura da sua resposta.</p>

			<sage>
				<input>
				a = 5
				b = 10
				c = 6
				d = 13
				a.divides(b)
				</input>
				<output>True</output>
			</sage>

			<sage>
				<input>not (b in [c,d])</input>
				<output>True</output>
			</sage>

			<sage>
				<input>a.divides(b) and not (b in [c,d])</input>
				<output>True</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="2">
		<statement>
			<p>Verifique a veracidade do Pequeno Teorema de Fermat (em qualquer uma de suas variantes) usando o número composto <m>391=17\cdot 23</m> como escolha de base (ou <m>a</m> ou <m>b</m>), e para <m>p</m> passando por todos os valores primos entre  <m>100</m> e <m>1000</m>.</p>

			<p>Construa a construção de forma devagar <mdash/> faça uma lista de potências (começando com poucos primos), então faça uma lista de potências reduzidas pela aitmética modular e depois uma lista de comparações com o valor previsto, agora verifique todos estes valores lógicos resultantes da comparação.  Esta é uma estratégia útil em muitos problemas similares.  Finalmente você poderá escrever uma só linha que realize a verificação completa e devolva <c>True</c>.  A seguir temos algumas dicas que podem ser úteis.</p>

			<sage>
				<input>
				a = 20
				b = 6
				a.mod(b)
				</input>
				<output>2</output>
			</sage>

			<sage>
				<input>prime_range(50, 100)</input>
				<output>[53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</output>
			</sage>

			<sage>
				<input>all([True, True, True, True])</input>
				<output>True</output>
			</sage>

			<sage>
				<input>all([True, True, False, True])</input>
				<output>False</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="3">
		<statement>
			<p>Verifique que o grupo de unidades  mod <m>n</m> tem ordem  <m>n-1</m> quando  <m>n</m> é primo, novamente para todos os primos entre <m>100</m> e <m>1000</m>.  Assim como antes, seu resultado deve ser simplesmente  <c>True</c>, uma única vez, indicando que a proposição sobre a ordem é verdadeira para todos os primos examinados.  Como antes, construa sua solução passo a passo e com conjuntos menores de primos no começo.  Expresse sua resposta como uma só linha de código  Sage.</p>
		</statement>
		
	</exercise>

	<exercise number="4">
		<statement>
			<p>Verifique o Teorema de  Euler para todos os valores <m>0\lt n\lt 100</m> y para <m>1\leq a \leq n</m>.  Isso requerirá proposições <c>for</c> aninhadas com um condicional.  Novamente, a seguir temos um pequeno exemplo que pode ser útil para construir sua linha única de código Sage.  Note o uso de <c>srange()</c> neste ejemplo.</p>

			<sage>
				<input>[a/b for a in srange(9) for b in srange(1,a) if gcd(a,b)==1]</input>
				<output>
				[2, 3, 3/2, 4, 4/3, 5, 5/2, 5/3, 5/4, 6, 6/5,
				 7, 7/2, 7/3, 7/4, 7/5, 7/6, 8, 8/3, 8/5, 8/7]
				</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="5">
		<statement>
			<p>O grupo simétrico em  <m>7</m> símbolos, <m>S_7</m>, tem <m>7! = 5040</m> elementos.  Considere as seguintes perguntas sem utilizar Sage, baseado no que sabemos sobre as ordens dos elementos em grupos de permutações (Exercício<nbsp/><xref ref="exercise-permute-order-product-cycles"/>).<ul>
				<li><p>Qual é a maior ordem possível?</p></li>
				<li><p>Quantos elementos existem de ordem <m>10</m>?</p></li>
				<li><p>Quantos elementos existem de ordem <m>1</m>?</p></li>
				<li><p>Quantos elementos existem de ordem <m>2</m>?</p></li>
				<li><p>Qual é o menor inteiro positivo para que não haja elemento dessa ordem?</p></li>
			</ul></p>

			<p>Estas perguntas serão mais fáceis se você for mais familiar com uso de coeficientes binomiais para contar em situações similarmente complexas.  Em qualquer caso, pense um pouco em cada questão (e talvez em alguma outra que lhe venha na cabeça) antes de começar a escrever em Sage.</p>

			<p>Agora, calcule quantos elementos existem de cada ordem usando o método <c>.order()</c>, e inclua isto em uma lista exaustiva que contenha o número de elemntos de cada ordem.  Você pode verificar seu trabalho (ou checar Sage) usando o comando  <c>sum()</c>  para somar esta lista e esperando econtrar <m>5040</m>.</p>

			<p>Comente o processo de primeiro estudar estas perguntas sem ajuda computacional e depois novamente com Sage.  Para que valores de <m>n</m> você acha que Sage seria um tanto quanto lento e sua mente mais rápida?</p>
		</statement>
		
	</exercise>

</exercises>
